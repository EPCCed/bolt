#!/usr/bin/python
#
# bolt job submission script production tool
#
#----------------------------------------------------------------------
# Copyright 2012 EPCC, The University of Edinburgh
#
# This file is part of bolt.
#
# bolt is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# bolt is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with bolt.  If not, see <http://www.gnu.org/licenses/>.
#----------------------------------------------------------------------
#
"""Produce job submission scripts using a common interface.

This tool produces job submission scripts for a variety of compute
resources and batch systems. It attempts to partition the work in a
pseudo-optimal way and select sensible options. It will also include
compusory options required on particular resources.

Limitations:
  + Currently designed for MPI (or CAF/UPC) jobs only. Jobs that
    use OpenMP threading are not supported.

OPTIONS

-a,--account <account>   Specify the account to charge the job to. If
                         not specified then it is not included in the
                         output.
                         
-b,--batch <batch>       Specify the batch system to create job submission
                         script for. Default is specified by the resource
                         configuration. Use the '-l' option to list valid
                         values.
                         
-h,--help                Show this help.

-l,--list                List the resources and batch systems available.

-n,--tasks <n>           Number of parallel tasks. Defaults to 1. If
                         number of parallel tasks is 1 then the tool
                         will try to produce a serial job submission
                         script (unless the '-p' option is specified).

-N,--tasks-per-node <n>  Number of parallel tasks per node. Defaults to
                         the minimum of the number of tasks or the number
                         of cores per node for the specified resource.

-o,--output <filename>   The output filename to use. The default is
                         "a.bolt".

-p,--force-parallel      Force the tool to create a parallel job even if
                         the number of tasks is 1.

-q,--queue <queue>       Specify the queue to submit the job to. This 
                         will usually be set correctly by default.

-r,--resource <resource> Specify the resource to create a job submission
                         script for. Default is set by the install system.
                         Use the '-l' option to list valid values.

-s,--submit              Submit the created job submission script to the
			 batch system. Default is not to submit job.
			 
-t,--job-time <hh:mm:ss> Specify the wallclock limit for the job.

"""
__author__ =  'Andrew Turner, EPCC'
__version__=  '0.2'

#===============================================================
# Simple Job Submission Tool
#
# Submit jobs to different compute resource batch systems using
# a common interface. Tries to optimally distribute parallel
# tasks across nodes.
#
# A. R. Turner, EPCC, 2012
#===============================================================
from resource import Resource
from batch import Batch
from job import Job
import error
import sys
import os
import fnmatch
import getopt
import subprocess
import ConfigParser
import grp

def main(argv):

        #=======================================================
	# Global configuration section
        #=======================================================
	# Read the tool configuration file here
	#  - Location of other configuration files
        #  - Default resource
        rootDir = os.environ['BOLT_DIR']
        globalConfig = {}
        globalConfig = readGlobalConfig(rootDir + "/configuration/global.config")
	defaultResource = globalConfig['defaultResource']

        #=======================================================
	# Read the defined resources and batch systems
        #=======================================================
        # Get a list of all the defined batch system.
        batchConfigDir = rootDir + '/configuration/batch'
        batches = []
        nBatch = 0
	# We also need to create a dictionary of batch systems here
	batchDict = {}
        for file in os.listdir(batchConfigDir):
                if fnmatch.fnmatch(file, '*.batch'):
                        nBatch += 1
                        batch = Batch()
                        batch.readConfig(batchConfigDir + '/' + file) 
                        batches.append(batch)
			batchDict[batch.name] = nBatch-1
        
        if nBatch == 0:
		error.handleError("No batch systems defined in {0}.\n".format(batchConfigDir))

        # Get a list of all the defined resources. If a user does not specify a 
        # resource then we will use resources[0] as the default
        resourceConfigDir = rootDir + '/configuration/resources'
        resources = []
        nResource = 0
	# We also need to create a dictionary of resources here
	resourceDict = {}
        for file in os.listdir(resourceConfigDir):
                if fnmatch.fnmatch(file, '*.resource'):
                        nResource += 1
			resource = Resource()
                        resource.readConfig(resourceConfigDir + '/' + file)
                        resources.append(resource)
			resourceDict[resource.name] = nResource-1
                        # Check we have a description of the batch system
                        name = resource.batch
			try:
				index = batchDict[name]
			except KeyError:
				error.handleError("Batch system not found: {0}. Known systems are {1}\n".format(name, batchDict.keys()))
        if nResource == 0:
		error.handleError("No resources defined in {0}.\n".format(resourceConfigDir))

        # Check that the default resource has been defined
	if defaultResource not in resourceDict:
		error.handleError("Default resource not found: {0}. Known resources are {1}\n".format(defaultResource, resourceDict.keys()))
		exit(1)
                
        # Create the job object
        job = Job()

        #=======================================================
	# Command line options
        #=======================================================
	# Read the command-line options
	try:
                opts, args = getopt.getopt(argv, "n:N:A:t:o:r:b:q:plsh", \
			       ["tasks=","tasks-per-node=","account=","job-time=", \
                                "output-file=","resource=","batch=","queue=", \
                                "force-parallel","list","submit","help"])
	except getopt.GetoptError:
	 	error.handleError("Could not parse command line options\n")

	# Set the initial values
	taskPerNodeSpecified = False
	forceParallel = False
	submitJob = False
	outputFileName = None
	outputFile = None
	selectedResource = None
	selectedBatch = None

	# Parse the command-line options
	for opt, arg in opts:
		if opt in ("-n", "--tasks"):
			job.setTasks(arg)
		if opt in ("-N", "--tasks-per-node"):
			job.setTasksPerNode(arg)
                        taskPerNodeSpecified = True
		if opt in ("-A", "--account"):
			job.setAccountID(arg)
		if opt in ("-t", "--job-time"):
			job.setWallTime(arg)
		if opt in ("-o", "--output-file"):
			outputFileName = arg
		if opt in ("-q", "--queue"):
			job.setQueue(arg)
		if opt in ("-p", "--force-parallel"):
			forceParallel = True
		if opt in ("-r", "--resource"):
			selectedResource = arg
			# Test if we know the specified resource
			if selectedResource not in resourceDict:
				error.handleError("Resource not found: {0}. Known resources are {1}\n".format(selectedResource, resourceDict.keys()))
		if opt in ("-s", "--submit"):
			submitJob = True
		if opt in ("-b", "--batch"):
			selectedBatch = arg
			# Test if we know the specified batch system
			if selectedBatch not in batchDict:
				error.handleError("Batch system not found: {0}. Known systems are {1}\n".format(selectedBatch, batchDict.keys()))
                if opt in ("-l", "--list"):
			listResources(resources, defaultResource)
			listBatch(batches, resources[resourceDict[defaultResource]].batch)
			exit(0)
                if opt in ("-h", "--help"):
			printHelp(rootDir)
			exit(0)

        # Check that we have an executable name to use
        if len(args) < 1:
		error.handleError("You must specify an executable name to use. Use 'bolt -h' to show correct usage.")

        # Is this a parallel job or not
	job.setIsParallel((job.pTasks > 1) or (forceParallel))

        #=======================================================
	# Set default job options
        #=======================================================
	# If output file name is specified then write to it - otherwise
	# use "a.bolt"
	if outputFileName is None: 
		error.printWarning("Using default output file name: a.bolt")
		outputFileName = "a.bolt"

	# Try to open the output file
        try:
		outputFile = open(outputFileName, "w")
	except IOError as (errno, strerror):
		error.handleError("Opening output file: {0}; {1}".format(outputFileName, strerror), errno)

	# If no resource or batch systems are specified then use the defaults
	if selectedResource is None: selectedResource = resources[resourceDict[defaultResource]].name
	if selectedBatch is None: selectedBatch = resources[resourceDict[selectedResource]].batch

        # For convenience, set the selected resource
        resource = resources[resourceDict[selectedResource]]

        # Default job name is the name of the executable
        if job.name is None:
        	error.printWarning("Setting job name to: " + args[0])
        	job.setName(args[0])

        # Default wall time is 5 minutes
        if job.wallTime is None: 
        	error.printWarning("Using default job walltime of 5 mins")
        	job.setWallTime("0:5:0")

        # Default number of tasks is 1
	if job.pTasks == 0:
		error.printWarning("Setting number of parallel tasks to 1")
		job.setTasks(1)

        # Default cores per node comes from the resource
	if job.pTasksPerNode == 0:
		error.printWarning("Setting number of tasks per node to " + str(resource.numCoresPerNode()))
		job.setTasksPerNode(min(job.pTasks, resource.numCoresPerNode()))
        if (job.accountID == "") or (job.accountID is None):
                if resource.defaultAccount == "group":
                        # Get account from *nix group
                        grpinfo = grp.getgrgid(os.getgid())
                        job.setAccountID(grpinfo[0])
                        error.printWarning("Setting accounting code to " + grpinfo[0])
                elif (resource.defaultAccount != "") or (resource.defaultAccount is not None):
                        job.setAccountID(resource.defaultAccount)
                        error.printWarning("Setting accounting code to " + resource.defaultAccount)

        # Default queues if needed
	if job.isParallel:
                if (job.queueName == "") or (job.queueName is None):
                        job.setQueue(resource.parallelQueue)
	else:
                if (job.queueName == "") or (job.queueName is None):
                        job.setQueue(resource.serialQueue)

        #=======================================================
	# Consistency checks
        #=======================================================
	# If we have selected the number of tasks per node we need to see if this
        # option is supported on the specified resource
	if taskPerNodeSpecified:
		if (resource.taskPerNodeOption == "")   or \
                   (resource.taskPerNodeOption == None):
			error.printWarning("Tasks per node specified ({0}) but option is not supported on resource {1}. {2} will be used.".format(job.pTasksPerNode, resource.name, min(job.pTasks, resource.numCoresPerNode())))
			job.setTasksPerNode(min(job.pTasks, resource.numCoresPerNode()))

        # Check that we have specified a sensible number of tasks for a parallel job
	if job.isParallel:
		job.checkTasks(resource)

        # Check that we have specified a sensible job time
        job.checkTime(resource)

        # Check that we have an account (if required)
        if resource.accountRequired:
                if (job.accountID == "") or (job.accountID is None):
			error.handleError("Account ID not specified (-A option) but resource {0} requires an account ID to be specified.".format(resource.name))

        #=======================================================
	# Write out the job script
        #=======================================================
	# Is this a serial or parallel job
	if job.isParallel:
                # Job command is the remaining arguments
                job.setJobCommand(' '.join(args))
		# For parallel jobs we need to compute the pseudo-optimal distribution of
		# tasks and set the parallel job launcher command
		job.setParallelRunLine(resource)
		# Write the parallel job script
		job.writeParallelJob(batches[batchDict[selectedBatch]], \
                                 resource, outputFile)
	else:
		# Job command is the remaining arguments
                job.setJobCommand(' '.join(args))
		# Write the parallel job script
		job.writeSerialJob(batches[batchDict[selectedBatch]], \
                                 resource, outputFile)

        # Close the file if we need to
	if outputFileName is not None: outputFile.close()
	
	#=======================================================
	# Submit the job if required
        #=======================================================
        if submitJob:
        	sys.stderr.write("Submitting job...\n")
        	subprocess.call([batches[batchDict[selectedBatch]].submitCommand, outputFileName])

	# Finish nicely
	exit(0)

def readGlobalConfig(fileName):
	"""Read the global configuration options from the specified file.

           Arguments:
              str fileName - Name of the config file
        """
        config = ConfigParser.SafeConfigParser()
        config.read(fileName)

        globalConfig = {}
        globalConfig['defaultResource'] = config.get("global options", "default resource")

        return globalConfig

def listResources(resources, defaultResource):
	"""List the defined compute resources and indicate the default.

           Arguments:
              dict resources       - Dictionary of defined resources
              str  defaultResource - Name of the default resource
        """
	sys.stdout.write("\nDefined resources (* = default):\n")
	for resource in resources:
		summary = resource.summaryString()
		if resource.name == defaultResource:
			sys.stdout.write("* " + summary + " *\n")
		else:
			sys.stdout.write("  " + summary + "  \n")
	sys.stdout.write("\n")


def listBatch(batches, defaultBatch):
	"""List the defined batch systems and indicate the default.

           Arguments:
              dict batches      - Dictionary of defined batch systems
              str  defaultBatch - Name of the default batch system
        """
	sys.stdout.write("\nDefined batch systems (* = default):\n")
	for batch in batches:
		summary = batch.summaryString()
		if batch.name == defaultBatch:
			sys.stdout.write("* " + summary + " *\n")
		else:
			sys.stdout.write("  " + summary + "  \n")
	sys.stdout.write("\n")

def printHelp(rootDir):
	"""Print help for the tool.
           
           Arguments:
              str rootDir - The root install directory of the tool.
        """
        subprocess.call(["pydoc", rootDir + "/bin/bolt"])

if __name__ == "__main__":
        main(sys.argv[1:])


